install_github(repo="DSTrading", username="IlyaKipnis")
#use packages
require(quantstrat)
require(quantstrat)
require(devtools)
require(DSTrading)
require(IKTrading)
require(quantstrat)
install_github(repo="IKTrading", username="IlyaKipnis")
install.packages("foreach")
require(quantstrat)
require(quantstrat)
require(devtools)
require(DSTrading)
install_github(repo="IKTrading", username="IlyaKipnis")
install_github(repo="DSTrading", username="IlyaKipnis")
require(quantstrat)
require(devtools)
require(IKTrading)
require(DSTrading)
#get chart data
getSymbols(Symbols="SPY", from="1998-01-01", to="2012-12-31")
#bring up candlestick chart
chart_Series(SPY)
#Calculate simple moving averages (SMA) of a series
#Cl=closing
sma <- SMA(x=Cl(SPY), n=200)
#adding an indicator to the SAME chart
#on=1 means the first window; adding the indicator to the price series
add_TA(sma, on=1, lwd=1.5, col="blue")
#The Relative Strength Index(RSI) calculates a ratio of the recent
#upward price movements to the absolute price movement
#No reason for n=2, it is just good
rsi <- RSI(price = Cl(SPY), n=2)
#adding normal(range bound) indicators in a separate window
add_TA(rsi, col="green", lwd=1.5)
#remove warnings
options("getSymbols.warning4.0"=FALSE)
#clear blotter environment
rm(list=ls(.blotter), envir=.blotter)
#define currency
currency('USD')
#define environmental time
Sys.setenv(TZ="UTC")
#name symbols
symbols <- "SPY"
#suppress messages as we get symbols
suppressMessages(getSymbols(symbols,from="1998-01-01", to="2012-12-31"))
#define stock
stock(symbols, currency="USD", multiplier=1)
#define initialization date
initDate="1990-01-01"
#define trade size
tradeSize <- 100000
#define initial equity
initEq <- tradeSize*length(symbols)
#name our strategy, portfolio and account so we know what's what
strategy.st <- portfolio.st <- account.st <- "RSI_10_6"
#remove the strategies to have a clean environment so it doesn't have an error
#of 'strategy already exists'
rm.strat(portfolio.st)
rm.strat(strategy.st)
#initialize portfolio, define account and initialize orders
initPortf(portfolio.st, symbols=symbols, initDate=initDate, currency='USD')
initAcct(account.st, portfolios=portfolio.st, initDate=initDate, currency='USD',
initEq=initEq)
initOrders(portfolio.st, initDate=initDate)
#initialize the strategy
strategy(strategy.st, store=TRUE)
#define parameters
#deals with the RSI; values for the RSI and the thresholds
nRSI = 2
thresh1 = 10
thresh2 = 6
#deals with the two SMAs; SMA exit parameter and filter
nSMAexit = 5
nSMAfilter = 200
#deals with the order sizing function; 10 day period, 2% of my notional trade size per trade
#in terms of 210-day ATR sizing so it buys more in good times and less in bad times
#osDollarATR (from IKTrading Package)
#this function allows us to size a position based on risk
period = 10
pctATR = .02
maxPct = .04
#indicators are merely computations based on market data
#they are mathematical calculations based on security price and/or volume
#Format: add.indicator(strategy.st, "name_of_function", arguments=list(inputs, to, the,
#function),label="name_after_function_name_and_period")
#one-day lagged ATR indicator for our order-sizing function (from IkTrading package)
#the mktdata object is your time series data
#HLC is a function that extracts the high, low, and close columns
#the quote encapsulation is the format for telling quantstrat that it will see the
#actual data
#indicators
add.indicator(strategy.st, name="lagATR", arguments=list(HLC=quote(HLC(mktdata)), n=period),
label="atrX")
add.indicator(strategy.st, name="RSI", arguments=list(price=quote(Cl(mktdata)), n=nRSI),
label="rsi")
add.indicator(strategy.st, name="SMA", arguments=list(x=quote(Cl(mktdata)), n=nSMAexit),
label="quickMA")
add.indicator(strategy.st, name="SMA", arguments=list(x=quote(Cl(mktdata)), n=nSMAfilter),
label="filterMA")
#signals are simply the interactions of the indicators with the market data
#signals tell us whether it is a good time to buy or sell a particular security
#they are usually treated as TRUE/FALSE values
#There are 4 types of signals:
#sigComparison: compares two values for a certain relationship (ie. close is greater than SMA200)
#sigCrossover: looks for a one-time change in a relationship between two values (ie. close crosses over SMA5)
#sigThreshold: compares whether a value crosses over a certain fixed value
#sigAND: a comparison specifying if both signals are true at the same time
#Format: add.signal(strategy.st, "signal_Function_Name", arguments=list(some inputs),
#label="what_the_signal_column_is_called)
#lt=less than, gt=greater than
#cross=FALSE means lower than/greater than ONLY, doesn't include equal to
#signals
add.signal(strategy.st, name="sigComparison", arguments=list(columns=c("Close","filterMA"),
relationship="gt"), label="upTrend")
add.signal(strategy.st, name="sigThreshold", arguments=list(column="rsi", threshold=thresh1,
relationship="lt", cross=FALSE), label="rsiThresh1")
add.signal(strategy.st, name="sigThreshold", arguments=list(column="rsi", threshold=thresh2,
relationship="lt", cross=FALSE), label="rsiThresh2")
add.signal(strategy.st, name="sigAND", arguments=list(columns=c("rsiThresh1", "upTrend"),
cross=TRUE), label="longEntry1")
add.signal(strategy.st, name="sigAND", arguments=list(columns=c("rsiThresh2", "upTrend"),
cross=TRUE), label="longEntry2")
add.signal(strategy.st, name="sigCrossover", arguments=list(columns=c("Close", "quickMA"),
relationship="gt"), label="exitLongNormal")
add.signal(strategy.st, name="sigCrossover", arguments=list(columns=c("Close", "filterMA"),
relationship="lt"), label="exitLongFilter")
#While there is only one rule fnction (ruleSignal), the makings of adding rules
#(how to place an order given having an observed a signal) are more nuanced.
#sigval=TRUE means we want it to fire when signal is true
#rules
add.rule(strategy.st, name="ruleSignal",
arguments=list(sigcol="longEntry1",
sigval=TRUE,
ordertype="market",
orderside="long",
replace=FALSE,
prefer="Open",
osFUN=osDollarATR,
tradeSize=tradeSize,
pctATR=pctATR,
maxPctATR=pctATR,
atrMod="X"),
type="enter", path.dep=TRUE, label="enterLong1")
add.rule(strategy.st, name="ruleSignal",
arguments=list(sigcol="longEntry2",
sigval=TRUE,
ordertype="market",
orderside="long",
replace=FALSE,
prefer="Open",
osFUN=osDollarATR,
tradeSize=tradeSize,
pctATR=pctATR,
maxPctATR=pctATR,
atrMod="X"),
type="enter", path.dep=TRUE, label="enterLong2")
add.rule(strategy.st, name="ruleSignal",
arguments=list(sigcol="exitLongNormal",
sigval=TRUE,
orderqty="all",
ordertype="market",
orderside="long",
replace=FALSE,
prefer="Open"),
type="exit", path.dep=TRUE, label="normalExitLong")
add.rule(strategy.st, name="ruleSignal",
arguments=list(sigcol="exitLongFilter",
sigval=TRUE,
orderqty="all",
ordertype="market",
orderside="long",
replace=FALSE,
prefer="Open"),
type="exit", path.dep=TRUE, label="filterExitLong")
t1 <- Sys.time()
out <- applyStrategy(strategy=strategy.st, portfolios=portfolio.st)
t2 <- Sys.time()
print(t2-t1)
updatePortf(portfolio.st)
dateRange <- time(getPortfolio(portfolio.st)$summary)[-1]
updateAcct(portfolio.st, dateRange)
updateEndEq(account.st)
#View mktdata object
View(mktdata['2004-11'])
t(tradeStats(portflio.st))
t(tradeStats(portflio.st))
tStats <- tradeStats(Portfolios=portfolio.st, use="trades", inclZeroDays = FALSE)
tStats[,4:ncol(tStats)] <- round(tStats[,4:ncol(tStats)], 2)
print(data.frame(t(tStats[,-c(1,2)])))
length(symbols)
(aggPF <- sum(tStats*Gross.Profits)/-sum(tStats$Gross.Losses))
(aggCorrect <- mean(tStats$Percent.Positive))
(numTrades <- sum(tStats$Num.Trades))
(meanAvgWLR <- mean(tStats$Avg.winLoss.Ratio[tStats$Avg.WinLoss.Ratio < Inf], na.rm=TRUE))
dStats <- dailyStats(Portfolios = portfolio.st, use="Equity")
rownames(dStats) <- gsub(".DailyEndEq","", rownames(dStats))
print(data.frame(t(dStats)))
print(data.frame(t(tStats[,-c(1,2)])))
library(shiny)
shiny::runGitHub('ShinyMongo', 'comsysto', subdir='ShinyApp')
shiny::runApp('NICO R/Intermediate R/Tutorial 11 - Creating webapps using Shiny/Database - Front End')
db.location <- "files/bloomberg.db"
bloomberg.db <- src_sqlite("files/bloomberg.db", create = F)
source("files/SRC_Bloomberg_sqlite.R")
db.location <- "files/bloomberg.db"
bloomberg.db <- src_sqlite("files/bloomberg.db", create = F)
c1 <- tbl(bloomberg.db, "elements")
bloomberg.db <- src_sqlite("files/bloomberg.db", create = F)
bloomberg.db <- src_sqlite("files/bloomberg.db")
bloomberg.db <- src_sqlite("files/bloomberg.db", create = F)
bloomberg.db <- src_sqlite("bloomberg.db", create = F)
# c1 <- tbl(bloomberg.db, "tickers")
# c2 <- tbl(bloomberg.db, "elements")
bloomberg.db <- src_sqlite("bloomberg.db", create = F)
db.location <- "files/bloomberg.db"
bloomberg.db <- src_sqlite("files/bloomberg.db", create = F)
shiny::runApp('NICO R/Intermediate R/Tutorial 11 - Creating webapps using Shiny/Database - Front End')
bloomberg.db <- src_sqlite("files/bloomberg.db", create = F)
rm(list=ls())
source("files/SRC_Bloomberg_sqlite.R")
db.location <- "files/bloomberg.db"
bloomberg.db <- src_sqlite("files/bloomberg.db", create = F)
source("files/SRC_Bloomberg_sqlite.R")
db.location <- "files/bloomberg.db"
bloomberg.db <- src_sqlite("files/bloomberg.db", create = F)
# c1 <- tbl(bloomberg.db, "tickers")
# c2 <- tbl(bloomberg.db, "elements")
# c3 <- tbl(bloomberg.db, "current") #34
# c4 <- tbl(bloomberg.db, "static") # 294
# c5 <- tbl(bloomberg.db, "estimates") # 358
# c6 <- tbl(bloomberg.db, "price") #1229
# c7 <- tbl(bloomberg.db, "price_estimates") #1247
shinyServer(function(input, output) {
getElementList <- reactive({
c1 <- tbl(bloomberg.db, "elements")
#list.of.elements <- get.list.of.elements.with.removal(db.location)
#list.of.elements <- data.frame(list.of.elements)
#colnames(list.of.elements) <- c(" ")
#return(list.of.elements)
return(data.frame(c1))
})
getTickerList <- reactive({
c2 <- tbl(bloomberg.db, "tickers")
#list.of.tickers <- get.list.of.tickers(db.location)
#list.of.tickers <- data.frame(list.of.tickers)
#colnames(list.of.tickers) <- c(" ")
#return(list.of.tickers)
return(data.frame(c2))
})
modifyTicker <- reactive({
input$tickerUpdateButton
isolate({
update.ticker.name(db.location, input$oldTicker, input$newTicker)
})
db.location <- "files/bloomberg.db"
source("files/SRC_Bloomberg_sqlite.R")
bloomberg.db <- src_sqlite("files/bloomberg.db", create = F)
source("files/SRC_Bloomberg_sqlite.R")
source("SRC_Bloomberg_sqlite.R")
source("files/SRC_Bloomberg_sqlite.R")
library(shiny)
source("files/SRC_Bloomberg_sqlite.R")
db.location <- "files/bloomberg.db"
bloomberg.db <- src_sqlite("files/bloomberg.db", create = F)
source("files/SRC_Bloomberg_sqlite.R")
shiny::runApp('NICO R/Intermediate R/Tutorial 11 - Creating webapps using Shiny/Bristol')
library(rpg)
#connect to database
connect(dbname = "postgres", host = "localhost")
#creating a schema
execute("CREATE SCHEMA rpgtesting")
execute("CREATE TABLE test (id integer, field text)")
#drop table if exists
execute("DROP TABLE IF EXISTS test")
#fetch data from database
fetch("select * from main.animals")
#insert into database
query("INSERT INTO main.animals VALUES ($1, $2, $3, $4, $5, $6, $7)", c(6, "M04", "Chris", "m", 3, 1, ""))
install.packages("pg")
install.packages("pg", repos = c("https://cran.rstudio.com","https://jangorecki.gitlab.io/logR","https://jangorecki.gitlab.io/pg"))
library(data.table)
library(logR)
library(pg)
?options
options("pg.conn" = pgConnect(dbname = "triumph", user = "viewuser", password = "DefaultPassword"))
options("pg.conn" = pgConnect(dbname = "bloomberg", user = "viewuser", password = "DefaultPassword"))
?pgConnect
options("pg.conn" = pgConnect(host="triumph-postgres.crm9dm8jf9cd.us-west-2.rds.amazonaws.com",
port = "5432",
dbname = "bloomberg",
user = "viewuser",
password = "DefaultPassword"))
pgDisconnect(conn = getOption("pg.conn"))
pgGetQuery("SELECT * FROM data;")
options("pg.conn" = pgConnect(host="triumph-postgres.crm9dm8jf9cd.us-west-2.rds.amazonaws.com",
port = "5432",
dbname = "bloomberg",
user = "viewuser",
password = "DefaultPassword"))
pgGetQuery("SELECT * FROM data;")
options("pg.conn" = pgConnect(host="triumph-postgres.crm9dm8jf9cd.us-west-2.rds.amazonaws.com",
port = "5432",
dbname = "bloomberg",
user = "viewuser",
password = "DefaultPassword"))
options("pg.conn" = pgConnect(host="triumph-postgres.crm9dm8jf9cd.us-west-2.rds.amazonaws.com",
port = "5432",
dbname = "bloomberg",
user = "viewuser",
password = "DefaultPasword"))
options("pg.conn" = pgConnect(host="triumph-postgres.crm9dm8jf9cd.us-west-2.rds.amazonaws.com",
port = "5432",
dbname = "bloomberg",
user = "viewuser",
password = "DefaultPassword"))
pgGetQuery("SELECT * FROM data;")
pgListTables("public")
options("pg.conn" = pgConnect(host="triumph-postgres.crm9dm8jf9cd.us-west-2.rds.amazonaws.com",
port = "5432",
dbname = "bloomberg",
user = "viewuser",
password = "DefaultPassword"))
library(data.table)
library(logR)
library(pg)
#connect to AWS PostGresSQL RDS Triumph bloomberg database
options("pg.conn" = pgConnect(host="triumph-postgres.crm9dm8jf9cd.us-west-2.rds.amazonaws.com",
port = "5432",
dbname = "bloomberg",
user = "viewuser",
password = "DefaultPassword"))
pgListTables("public")
pgGetQuery("SELECT * FROM data;")
#Disconnect from database
pgDisconnect(conn = getOption("pg.conn"))
options("pg.conn" = pgConnect(host="triumph-postgres.crm9dm8jf9cd.us-west-2.rds.amazonaws.com",
port = "5432",
dbname = "bloomberg",
user = "triumph",
password = "Password123."))
pgListTables("public")
pgGetQuery("SELECT * FROM data;")
pgGetQuery("SELECT * FROM errors;")
options("pg.conn" = pgConnect(host="triumph-postgres.crm9dm8jf9cd.us-west-2.rds.amazonaws.com",
port = "5432",
dbname = "bloomberg",
user = "viewuser",
password = "DefaultPassword"))
pgGetQuery("SELECT * FROM data;", .log = FALSE)
pgGetQuery("SELECT * FROM data;")
pgDisconnect(conn = getOption("pg.conn"))
pgConnect(host="triumph-postgres.crm9dm8jf9cd.us-west-2.rds.amazonaws.com",
port = "5432",
dbname = "bloomberg",
user = "viewuser",
password = "DefaultPassword")
pgListTables("public")
pgGetQuery("SELECT * FROM data;")
install.packages("rpg")
library("rpg")
library(rpg)
?rpg
?connect
connect("dbname = bloomberg host = triumph-postgres.crm9dm8jf9cd.us-west-2.rds.amazonaws.com")
connect("dbname = bloomberg host = triumph-postgres.crm9dm8jf9cd.us-west-2.rds.amazonaws.com username=triumph")
connect("dbname = bloomberg host = triumph-postgres.crm9dm8jf9cd.us-west-2.rds.amazonaws.com user=triumph")
source('C:/Users/culla/Dropbox/NLA/NLA Triumph Bloomberg DB/Bloomberg-Postgres.R', echo=TRUE)
install.packages("pg", repos = c("https://cran.rstudio.com",
fetch("select * from data")
library(rpg)
#connect to AWS PostGresSQL RDS Triumph bloomberg database
connect("dbname = bloomberg host = triumph-postgres.crm9dm8jf9cd.us-west-2.rds.amazonaws.com user=triumph")
fetch("select * from data")
fetch("SELECT typ.type, ele.element, dat.date, dat.value, err.error FROM data dat
INNER JOIN errors err ON (dat.error_id = err.error_id)
INNER JOIN types typ ON (dat.type_id = typ.type_id)
INNER JOIN elements ele ON (dat.element_id = ele.element_id)
WHERE err.error_id != 1
ORDER BY date DESC;")
fetch("SELECT typ.type, ele.element, dat.date, dat.value, err.error FROM data dat
INNER JOIN errors err ON (dat.error_id = err.error_id)
INNER JOIN types typ ON (dat.type_id = typ.type_id)
INNER JOIN elements ele ON (dat.element_id = ele.element_id)
WHERE err.error_id != 1
ORDER BY date DESC;")
a <- fetch("SELECT typ.type, ele.element, dat.date, dat.value, err.error FROM data dat
INNER JOIN errors err ON (dat.error_id = err.error_id)
INNER JOIN types typ ON (dat.type_id = typ.type_id)
INNER JOIN elements ele ON (dat.element_id = ele.element_id)
WHERE err.error_id != 1
ORDER BY date DESC;")
str(a)
a
rm(list=ls())
show_conn_stack()
disconect()
disconnect()
connect("dbname = bloomberg host = triumph-postgres.crm9dm8jf9cd.us-west-2.rds.amazonaws.com user=viewsuer")
connect("dbname = bloomberg host = triumph-postgres.crm9dm8jf9cd.us-west-2.rds.amazonaws.com user=viewuser")
fetch("SELECT typ.type, ele.element, dat.date, dat.value, err.error FROM data dat
INNER JOIN errors err ON (dat.error_id = err.error_id)
INNER JOIN types typ ON (dat.type_id = typ.type_id)
INNER JOIN elements ele ON (dat.element_id = ele.element_id)
WHERE err.error_id != 1
ORDER BY date DESC;")
fetch("SELECT typ.type, ele.element, dat.date, dat.value, err.error FROM data dat
INNER JOIN errors err ON (dat.error_id = err.error_id)
INNER JOIN types typ ON (dat.type_id = typ.type_id)
INNER JOIN elements ele ON (dat.element_id = ele.element_id)
WHERE err.error_id != 1
ORDER BY date DESC;")
fetch("SELECT typ.type, ele.element, dat.date, dat.value, err.error FROM data dat
INNER JOIN errors err ON (dat.error_id = err.error_id)
INNER JOIN types typ ON (dat.type_id = typ.type_id)
INNER JOIN elements ele ON (dat.element_id = ele.element_id)
WHERE err.error_id != 1
ORDER BY date DESC;")
fetch("SELECT typ.type, ele.element, dat.date, dat.value, err.error FROM data dat
INNER JOIN errors err ON (dat.error_id = err.error_id)
INNER JOIN types typ ON (dat.type_id = typ.type_id)
INNER JOIN elements ele ON (dat.element_id = ele.element_id)
WHERE err.error_id != 1
ORDER BY date DESC;")
fetch("SELECT typ.type, ele.element, dat.date, dat.value, err.error FROM data dat
INNER JOIN errors err ON (dat.error_id = err.error_id)
INNER JOIN types typ ON (dat.type_id = typ.type_id)
INNER JOIN elements ele ON (dat.element_id = ele.element_id)
WHERE err.error_id != 1
ORDER BY date DESC;")
fetch("SELECT typ.type, ele.element, dat.date, dat.value, err.error FROM data dat
INNER JOIN errors err ON (dat.error_id = err.error_id)
INNER JOIN types typ ON (dat.type_id = typ.type_id)
INNER JOIN elements ele ON (dat.element_id = ele.element_id)
WHERE err.error_id != 1
ORDER BY date DESC;")
fetch("SELECT * FROM data;")
p <- fetch("SELECT * FROM data;")
rm(list=ls())
p <- fetch("SELECT * FROM data;")
library(rpg)
#connect to AWS PostGresSQL RDS Triumph bloomberg database
library(rpg)
#connect to AWS PostGresSQL RDS Triumph bloomberg database
connect("dbname = bloomberg host = triumph-postgres.crm9dm8jf9cd.us-west-2.rds.amazonaws.com user=viewuser")
#use fetch for selecting
fetch("SELECT typ.type, ele.element, dat.date, dat.value, err.error FROM data dat
INNER JOIN errors err ON (dat.error_id = err.error_id)
INNER JOIN types typ ON (dat.type_id = typ.type_id)
INNER JOIN elements ele ON (dat.element_id = ele.element_id)
WHERE err.error_id != 1
ORDER BY date DESC;")
rm(list=ls())
p <- fetch("SELECT * FROM data;")
fetch
data.table
?data.table
library(data.table)
p <- data.table(fetch("SELECT * FROM data;"))
str(p)
startTime <- Sys.time()
p <- data.table(fetch("SELECT * FROM data;"))
endTime <- Sys.time()
elapsed <- endTime - startTime
?Sys.time
cat(elapsed)
startTime <- Sys.time()
p <- data.table(fetch("SELECT * FROM data;"))
endTime <- Sys.time()
elapsed <- endTime - startTime
cat(elapsed)
startTime <- Sys.time()
p <- fetch("SELECT * FROM data;")
endTime <- Sys.time()
elapsed <- endTime - startTime
cat(elapsed)
startTime <- Sys.time()
p <- fetch("SELECT * FROM data;")
endTime <- Sys.time()
elapsed <- endTime - startTime
cat(elapsed)
p <- fetch("SELECT * FROM data;")
startTime <- Sys.time()
p <- fetch("SELECT * FROM data;")
endTime <- Sys.time()
elapsed <- endTime - startTime
cat(elapsed)
knit.rmd.file("RMD/Gerber_Statistic_and_Hierarchical_Risk_Parity/Gerber_Statistic_and_Hierarchical_Risk_Parity.Rmd", "_posts/2016-05-30-Gerber_Statistic_and_Hierarchical_Risk_Parity.md")
library(knitr)
# SETUP: Load the knit.rmd.file function
knit.rmd.file <- function(input.path, output.path){
VAR <- ""
knitr::knit(input=input.path, output=output.path)
# knitr::knit(input="RMD/FAA-Strategy/FAA_Explanation.Rmd", output="_posts/2016-05-16-FAA_Explanation.md")
VAR <- "http://nextlevelanalytics.github.io/"
knitr::knit(input=input.path, output=output.path)
#knitr::knit(input="RMD/FAA-Strategy/FAA_Explanation.Rmd", output="_posts/2016-05-16-FAA_Explanation.md")
}
knit.rmd.file("RMD/Gerber_Statistic_and_Hierarchical_Risk_Parity/Gerber_Statistic_and_Hierarchical_Risk_Parity.Rmd", "_posts/2016-05-30-Gerber_Statistic_and_Hierarchical_Risk_Parity.md")
setwd("C:/Users/culla/Dropbox/NLA/NLA Github/nextlevelanalytics.github.io")
knit.rmd.file("RMD/Gerber_Statistic_and_Hierarchical_Risk_Parity/Gerber_Statistic_and_Hierarchical_Risk_Parity.Rmd", "_posts/2016-05-30-Gerber_Statistic_and_Hierarchical_Risk_Parity.md")
knit.rmd.file <- function(input.path, output.path){
VAR <- ""
knitr::knit(input=input.path, output=output.path)
# knitr::knit(input="RMD/FAA-Strategy/FAA_Explanation.Rmd", output="_posts/2016-05-16-FAA_Explanation.md")
VAR <- "/"
knitr::knit(input=input.path, output=output.path)
#knitr::knit(input="RMD/FAA-Strategy/FAA_Explanation.Rmd", output="_posts/2016-05-16-FAA_Explanation.md")
}
knit.rmd.file("RMD/Gerber_Statistic_and_Hierarchical_Risk_Parity/Gerber_Statistic_and_Hierarchical_Risk_Parity.Rmd", "_posts/2016-05-30-Gerber_Statistic_and_Hierarchical_Risk_Parity.md")
